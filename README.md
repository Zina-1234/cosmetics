# üß¥ Analysis of regulated ingredients in cosmetic products

> Automated detection of restricted and CMR substances in cosmetic products using the official EU CosIng Annex III regulatory database.

---

## üìå Overview

EU Regulation 1223/2009 restricts the use of ~375 cosmetic ingredients (Annex III), including CMR substances (Carcinogenic, Mutagenic, or Reprotoxic). Checking a product's INCI ingredient list against this regulation manually takes **2‚Äì3 hours per product**.

This project automates that process end-to-end:

1. Load and clean the CosIng regulatory reference, the Sephora catalog, and the Skincare catalog
2. Normalize raw INCI ingredient names so they can be reliably matched across sources
3. Flag every product row with `restricted_ingredient` and `cmr` binary indicators
4. Aggregate those flags to product level (counts + boolean flags)
5. Export clean, dashboard-ready CSVs for MySQL and Tableau

**Result:** 10,451 products screened ‚Äî 75.87% of Sephora products and 62.8% of Skincare products contain at least one restricted ingredient.

---

## üìÅ Repository Structure

```
project/
‚îÇ
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ raw/                                  ‚Üê source files (not committed to git)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ COSING_Annex_III_v2.xls           # EU CosIng Annex III list
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ product_info.csv                  # Sephora product catalog
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cosmetics.csv                     # Skincare product catalog
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ processed/                            ‚Üê generated by the notebook
‚îÇ       ‚îú‚îÄ‚îÄ cosing_clean.csv                  # one row per normalized ingredient
‚îÇ       ‚îú‚îÄ‚îÄ sephora_clean.csv                 # one row per product‚Äìingredient pair
‚îÇ       ‚îú‚îÄ‚îÄ skincare_clean.csv                # one row per product‚Äìingredient pair
‚îÇ       ‚îú‚îÄ‚îÄ sephora_dashboard_data.csv        # product-level aggregation for MySQL/Tableau
‚îÇ       ‚îî‚îÄ‚îÄ skincare_dashboard_data.csv       # product-level aggregation for MySQL/Tableau
‚îÇ
‚îú‚îÄ‚îÄ notebooks/
‚îÇ   ‚îî‚îÄ‚îÄ data_preparation_and_analysis.ipynb  ‚Üê main notebook (run top to bottom)
‚îÇ
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ README.md
```

---

## üì¶ Datasets

### CosIng Annex III ‚Äî `COSING_Annex_III_v2.xls`
| Field | Details |
|-------|---------|
| Source | European Commission ‚Äî [ec.europa.eu/growth/tools-databases/cosing](https://ec.europa.eu/growth/tools-databases/cosing) |
| Content | 375 restricted ingredients with restriction conditions, max concentrations, CMR classification, and applicable product types |
| Format | Excel `.xls`, Latin-1 encoding |
| Key columns used | `Name of Common Ingredients Glossary`, `Chemical name / INN`, `CMR`, `Product Type, body parts` |

### Sephora Products ‚Äî `product_info.csv`
| Field | Details |
|-------|---------|
| Source | Sephora e-commerce product catalog |
| Content | 8,494 cosmetic products with full INCI ingredient lists, prices, ratings, and engagement metrics |
| Format | CSV, UTF-8 |
| Key columns used | `product_id`, `product_name`, `brand_name`, `ingredients`, `price_usd`, `rating`, `reviews`, `loves_count`, `primary_category`, `secondary_category` |

### Skincare Products ‚Äî `cosmetics.csv`
| Field | Details |
|-------|---------|
| Source | Skincare product catalog |
| Content | 1,472 products across skincare categories |
| Format | CSV, UTF-8 |
| Key columns used | `Label`, `Brand`, `Name`, `Price`, `Rank`, `Ingredients` |

---

## ‚öôÔ∏è Installation

**Requirements:** Python 3.9+  ¬∑  MySQL 8.0 (optional ‚Äî only needed for the database export section)

```bash
# 1. Clone the repo
git clone https://github.com/Zina-1234/cosmetics.git
cd cosmetics

# 2. Create and activate a virtual environment
python -m venv venv
source venv/bin/activate        # macOS / Linux
# venv\Scripts\activate         # Windows

# 3. Install dependencies
pip install -r requirements.txt
```

**`requirements.txt`**
```
asttokens==3.0.1
beautifulsoup4==4.14.3
blinker==1.9.0
certifi==2026.1.4
charset-normalizer==3.4.4
click==8.3.1
colorama==0.4.6
comm==0.2.3
contourpy==1.3.3
cycler==0.12.1
debugpy==1.8.20
decorator==5.2.1
et_xmlfile==2.0.0
executing==2.2.1
Flask==3.1.2
flask-cors==6.0.2
fonttools==4.61.1
greenlet==3.3.1
idna==3.11
ipykernel==7.1.0
ipython==9.10.0
ipython_pygments_lexers==1.1.1
itsdangerous==2.2.0
jedi==0.19.2
Jinja2==3.1.6
joblib==1.5.3
jupyter_client==8.8.0
jupyter_core==5.9.1
kiwisolver==1.4.9
lxml==6.0.2
MarkupSafe==3.0.3
matplotlib==3.10.8
matplotlib-inline==0.2.1
nest-asyncio==1.6.0
numpy==2.4.2
openpyxl==3.1.5
packaging==26.0
pandas==3.0.0
parso==0.8.5
pillow==12.1.0
platformdirs==4.5.1
prompt_toolkit==3.0.52
psutil==7.2.2
pure_eval==0.2.3
Pygments==2.19.2
PyMySQL==1.1.2
pyparsing==3.3.2
python-dateutil==2.9.0.post0
python-dotenv==1.2.1
pyzmq==27.1.0
requests==2.32.5
scikit-learn==1.8.0
scipy==1.17.0
seaborn==0.13.2
six==1.17.0
soupsieve==2.8.3
SQLAlchemy==2.0.46
stack-data==0.6.3
threadpoolctl==3.6.0
tornado==6.5.4
traitlets==5.14.3
typing_extensions==4.15.0
tzdata==2025.3
urllib3==2.6.3
wcwidth==0.5.3
Werkzeug==3.1.5
xlrd==2.0.2
```

---

## üöÄ Usage

### Run the full pipeline

Open `notebooks/data_preparation_and_analysis.ipynb` and run all cells from top to bottom.

Before running, update the three file paths to point to your local copies of the raw data:

```python
# Section 1.1 ‚Äî CosIng
cosing_raw_0 = pd.read_excel("data/raw/COSING_Annex_III_v2.xls")

# Section 1.2 ‚Äî Sephora
sephora_raw_0 = pd.read_csv("data/raw/product_info.csv")

# Section 1.3 ‚Äî Skincare
skincare_raw_0 = pd.read_csv("data/raw/cosmetics.csv")
```

The notebook will automatically write all five processed CSVs to `data/processed/`.

### Export to MySQL (optional)

In the **"Export CSV files to MySQL Workbench"** section, update your credentials and run those cells:

```python
user     = "root"
password = getpass.getpass()          # prompted at runtime ‚Äî never hardcoded
database = "cosmetics_regulatory_db"
host     = "localhost"
port     = 3306
```

> ‚ö†Ô∏è The Skincare table renames `rank` ‚Üí `rating` before export because `RANK` is a reserved keyword in MySQL.

---

## üìì Notebook Walkthrough

### Section 1 ‚Äî Data Cleaning & Wrangling

#### 1.1 CosIng

The CosIng Excel file is the regulatory reference. Several quality issues are fixed before use:

| Problem | Fix |
|---------|-----|
| Typo in CMR column: `"equael"` | Replaced with `"equal"` |
| `NaN` stored as string `"nan"` in CMR column | Restored to `pd.NA` |
| Empty parentheses `()` in CMR values | Removed with `re.sub(r"\(\)", "", ...)` |
| Ingredient names stored as semicolon-separated synonyms | Split on `;\s*`, then exploded to one row per name |
| Missing names in `Name of Common Ingredients Glossary` | Backfilled from `Chemical name / INN`, Title-cased |
| Mixed casing and extra whitespace | `.str.strip().str.upper()` |
| Administrative junk rows | Rows where `ingredient == "MOVED OR DELETED"` dropped |
| `Product Type, body parts` contains newlines and noise | Cleaned with `re.sub`, split on regulatory separators `(a);` |

Final CosIng DataFrame kept to three columns:
```python
cosing = cosing_exploded[["ingredient", "cmr", "product_type"]].copy()
```

**Output:** `cosing_clean.csv`

---

#### 1.2 Sephora

```python
# Columns kept
cols_to_keep = [
    "product_id", "product_name", "brand_name",
    "ingredients", "price_usd", "rating", "reviews", "loves_count",
    "primary_category", "secondary_category", "tertiary_category",
    "sephora_exclusive", "online_only", "limited_edition", "new"
]

# Product categories kept
cosmetic_categories = [
    "Fragrance", "Bath & Body", "Hair",
    "Makeup", "Skincare", "Men", "Mini Size", "Gifts"
]

# Secondary categories excluded
exclude_categories = [
    "Brushes & Applicators", "Candles & Home Scents",
    "Beauty Supplements", "Tools"
]
```

The `ingredients` column is stored as a Python list literal string (e.g. `"['AQUA', 'GLYCERIN, PARFUM']"`). It is parsed through a 4-step pipeline:

```
ingredients (string)
  ‚Üí parse_ingredient_list()   # ast.literal_eval ‚Äî converts string to Python list
  ‚Üí split_ingredients()       # splits each list item further on commas
  ‚Üí explode()                 # one row per raw ingredient string
  ‚Üí clean_inci()              # uppercase, strip parentheses, remove non-alpha
```

**`clean_inci()` ‚Äî INCI normalization function:**
```python
def clean_inci(x):
    if pd.isna(x):
        return pd.NA
    x = x.upper()
    x = re.sub(r"\(.*?\)", "", x)    # remove parenthetical content
    x = re.sub(r"[^A-Z\s]", "", x)  # remove dots, numbers, punctuation
    x = re.sub(r"\s+", " ", x).strip()
    return x
```

Final Sephora DataFrame:
```python
sephora = sephora[["product_id", "product_name", "brand_name", "product_type",
                    "ingredient", "price_usd", "rating", "reviews", "loves_count"]]
```

**Output:** `sephora_clean.csv`

---

#### 1.3 Skincare

```python
# Columns kept, headers lowercased
skincare_raw = skincare_raw[["Label", "Brand", "Name", "Price", "Rank", "Ingredients"]]
skincare_raw.columns = skincare_raw.columns.str.lower()
```

Ingredient parsing is simpler ‚Äî ingredients are comma-separated plain text:

```python
def clean_ingredients(text):
    parts = text.split(",")
    return [p.strip().upper() for p in parts if p.strip()]
```

Additional fixes applied after exploding:
- **Trailing dots** removed: `str.replace(r"\.$", "", regex=True)`
- **Placeholder rows** removed: rows where `ingredients` or `ingredient` starts with `"Visit"` (these rows contain a redirect URL instead of actual ingredients)
- **`product_type`** derived from the `label` column in Title Case
- **Final columns kept:** `brand`, `name`, `product_type`, `ingredient`, `price`, `rank`

**Output:** `skincare_clean.csv`

---

### Section 2 ‚Äî Feature Engineering & Data Preparation

#### 2.1 Regulatory Feature Creation

Two reference lists are derived from the cleaned CosIng data:

```python
# Every ingredient appearing in Annex III
restricted_ingredients = cosing_clean['ingredient'].unique().tolist()

# CMR-classified subset (rows where cmr column is not null)
cmr_ingredients = cosing_clean[cosing_clean['cmr'].notnull()]['ingredient'].unique().tolist()
```

Both product datasets get two new binary columns:

```python
df['restricted_ingredient'] = df['ingredient'].apply(
    lambda x: 1 if x in restricted_ingredients else 0
)
df['cmr'] = df['ingredient'].apply(
    lambda x: 1 if x in cmr_ingredients else 0
)
```

#### 2.2 Product-Level Aggregation

Ingredient-level rows are collapsed back to one row per product:

**Sephora** ‚Äî `groupby('product_id')`:

| Output column | Aggregation |
|---------------|-------------|
| `product_name`, `brand_name`, `product_type`, `price_usd` | `first` |
| `rating` | `mean` |
| `reviews`, `loves_count` | `sum` |
| `restricted_ingredient_count` | `sum` |
| `cmr_count` | `sum` |
| `has_restricted_ingredient` | `max` ‚Üí binary flag |
| `has_cmr` | `max` ‚Üí binary flag |

**Skincare** ‚Äî `groupby(['brand', 'name'])`, same aggregation pattern.

---

### Section 3 ‚Äî Statistical Analysis & Insights

#### 3.1 Prevalence of Restricted and CMR Substances

```python
total_products      = sephora_agg.shape[0]
restricted_products = sephora_agg['has_restricted_ingredient'].sum()
cmr_products        = sephora_agg['has_cmr'].sum()

print(f"Products with restricted ingredients: {restricted_products / total_products:.1%}")
print(f"Products with CMR ingredients:        {cmr_products / total_products:.1%}")
```

#### 3.2 Risk Comparison Across Product Types, Brands, and Market Segments

**By product type** ‚Äî `groupby('product_type')` ‚Üí `restricted_pct`, `cmr_pct` per category

**By brand** ‚Äî `groupby('brand_name')` ‚Üí top 10 brands sorted by total restricted product count

**By market metrics** ‚Äî products split into `restricted` vs `non_restricted`, then `.mean()` on `price_usd`, `rating`, `reviews`, `loves_count`

#### 3.3 Visual Summary

```python
import matplotlib.pyplot as plt
import seaborn as sns

# % of products with restricted ingredients by category (top 15)
sns.barplot(
    data=type_summary.head(15),
    x='restricted_pct',
    y='product_type',
    palette='Reds_r'
)
plt.title('Top 15 Product Types by % of Products with Restricted Ingredients')
plt.xlabel('% of Products with Restricted Ingredients')
plt.ylabel('Product Type')
plt.show()
```

---

### Section 4 ‚Äî Dashboard Export

Percentage risk columns are added before export so Tableau and MySQL can use them directly:

```python
df['restricted_pct'] = df['restricted_ingredient_count'] / df['restricted_ingredient_count'].max() * 100
df['cmr_pct']        = df['cmr_count'] / df['cmr_count'].max() * 100
```

Files saved with two specific options:

```python
df.to_csv(
    'data/processed/sephora_dashboard_data.csv',
    index=False,
    encoding='utf-8-sig',  # UTF-8 BOM ‚Äî required for correct import in Excel and Tableau
    quoting=1              # csv.QUOTE_ALL ‚Äî quotes every field to handle commas in ingredient strings
)
```

---

## ü§ñ Machine Learning

### Objective

**Research question:** Can product ratings be predicted from objective characteristics ‚Äî price, ingredient risk profile, brand, and product type?

**Business value:** Pre-launch rating estimates, pricing optimization, and R&D prioritization without running a full consumer panel.

---

### Features (13 total)

| Group | Features |
|-------|----------|
| Price | `price_usd`, `log_price` (log-transformed to handle right skew) |
| Ingredient risk | `restricted_ingredient_count`, `cmr_count`, `has_restricted_ingredient`, `has_cmr` |
| Category | `product_type_encoded` (label-encoded), `brand_encoded` (487 brands) |
| Derived | `risk_density` = restricted_count / 15, `cmr_ratio` = cmr_count / (restricted_count + 1) |
| Interactions | `price_per_restricted`, `price_x_type`, `price_x_restricted` |

**Target:** `rating` (continuous, 0‚Äì5 ‚òÖ)  
**Split:** 80% train (5,736 products) / 20% test (1,434 products)  
**Preprocessing:** `StandardScaler` on all features

---

### Model Comparison

Five algorithms were trained and evaluated:

| Model | RMSE | MAE | R¬≤ |
|-------|------|-----|-----|
| **Linear Regression** ‚úÖ | **0.4695** | 0.3497 | 0.0358 |
| Ridge Regression | 0.4695 | 0.3497 | 0.0358 |
| Lasso Regression | 0.4729 | 0.3535 | 0.0218 |
| Random Forest | 0.4687 | 0.3453 | 0.0392 |
| Gradient Boosting | 0.4701 | 0.3452 | 0.0334 |

**Model selected: Linear Regression**

A paired t-test on 10-fold cross-validation scores returned p = 0.31 ‚Äî no statistically significant difference between any of the five models. Linear Regression was chosen by Occam's Razor: simplest model, interpretable coefficients, <1 ms inference, 12 KB saved file.

```python
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled  = scaler.transform(X_test)

model = LinearRegression()
model.fit(X_train_scaled, y_train)
```

---

### Key Findings

#### Finding 1 ‚Äî Ratings are fundamentally subjective (R¬≤ = 3.6%)

The model explains only 3.6% of rating variance. This is not a model failure ‚Äî it is a discovery. The remaining **96% of variance** comes from factors not present in the data: scent, texture, skin feel, packaging aesthetics, marketing influence, and individual skin chemistry. You cannot engineer a 5-star product through formulation alone.

#### Finding 2 ‚Äî Price anchoring is the strongest predictor

| Feature | Coefficient | Interpretation |
|---------|-------------|----------------|
| `log_price` | +0.0244 | Strongest single feature (24% importance) |
| `price_usd` | +0.0241 | Each $1 increase ‚Üí +0.024 predicted stars |
| `price_per_restricted` | +0.0137 | Price-to-risk ratio positive |
| `brand_encoded` | +0.0119 | Brand identity accounts for ~12% |
| `price_x_restricted` | +0.0088 | Expensive + restricted = perceived premium |

Customers rate expensive products higher to justify their purchase ‚Äî a known cognitive bias called **price anchoring**. The optimal price-to-rating ratio sits in the **$40‚Äì60** range; gains diminish above $80.

#### Finding 3 ‚Äî The Safety Paradox

| Safety profile | Average rating |
|----------------|---------------|
| No restricted ingredients | 4.152 ‚òÖ |
| Has restricted ingredients | 4.218 ‚òÖ (+1.6%) |
| Has CMR ingredients | 4.248 ‚òÖ (+2.3%) |

Products with dangerous ingredients are rated *higher*, not lower. Customers do not read or interpret INCI lists at point of purchase. Premium brands use complex formulations that trigger more restrictions, but their marketing and packaging drive ratings upward regardless. This means reformulating away from non-CMR restricted ingredients will not improve consumer ratings ‚Äî but removing CMR substances remains an ethical and regulatory imperative.

---

### Saved Artifacts

```
models/
‚îú‚îÄ‚îÄ rating_predictor_linear.pkl   # 12 KB ‚Äî trained Linear Regression model
‚îú‚îÄ‚îÄ scaler.pkl                    # 8 KB  ‚Äî fitted StandardScaler
‚îú‚îÄ‚îÄ label_encoder_type.pkl        # 2 KB  ‚Äî product type encoder
‚îî‚îÄ‚îÄ label_encoder_brand.pkl       # 15 KB ‚Äî brand encoder (487 brands)
```

The model is exposed as a REST API endpoint:

```
POST /api/predict-rating
Authorization: Bearer <token>
Body: { "price_usd": 45, "restricted_ingredient_count": 5, "has_cmr": 0, "product_type": "Skincare", "brand": "CLINIQUE" }

Response: { "predicted_rating": 4.28, "confidence_interval": [3.81, 4.75], "rmse": 0.4695 }
```

---

## üìä Key Results

| Metric | Sephora | Skincare |
|--------|---------|----------|
| Products analyzed | 8,494 | 1,472 |
| Has restricted ingredients | **72.1%** | 62.8% |
| Has CMR ingredients | 3.4% | **6.0%** |
| Avg restricted ingredients / product | 9.3 | 7.8 |
| Highest-risk category | Fragrance ‚Äî 84.2% | ‚Äî |

**Key findings:**

- **Fragrances are the highest-risk category** (84.2%) ‚Äî allergenic compounds such as LIMONENE, LINALOOL, and CITRONELLOL are restricted above trace concentrations under EU regulation
- **Safety paradox** ‚Äî products with CMR ingredients average *higher* consumer ratings (4.248 ‚òÖ) than fully safe products (4.152 ‚òÖ); price anchoring and brand prestige dominate ingredient safety in customer perception
- **Premium brands** (Chanel, Dior, YSL, Lanc√¥me) appear most frequently in the CMR product list, suggesting their complex luxury formulations trigger more regulatory restrictions

---

## üõ†Ô∏è Tech Stack

| Tool | Version | Role |
|------|---------|------|
| Python | 3.11 | Core language |
| pandas | 2.x | Data loading, cleaning, aggregation |
| NumPy | 1.24+ | Numerical operations |
| `re` (stdlib) | ‚Äî | INCI name normalization via regex |
| `ast` (stdlib) | ‚Äî | Safe parsing of Python list literal strings |
| matplotlib | 3.7+ | Plotting |
| seaborn | 0.12+ | Statistical visualizations |
| scikit-learn | 1.3+ | ML models, StandardScaler, cross-validation |
| SQLAlchemy + PyMySQL | 2.x / 1.1+ | MySQL connection and table export |
| Jupyter Notebook | 1.x | Interactive analysis environment |

---

## üéì RNCP Competencies

| # | Competency | How it is demonstrated |
|---|------------|------------------------|
| **C1** | Multi-source data collection | Three source types: Excel (CosIng), CSV (Sephora, Skincare), MySQL (export + re-import); REST API and web scraping handled in `extract_data.py` |
| **C2** | SQL analysis | 8 analytical queries in MySQL ‚Äî CMR product ranking, category risk breakdown, brand comparison, market metric comparison |
| **C3** | Data aggregation | 4-step documented pipeline: Explode ‚Üí Normalize ‚Üí Match ‚Üí Aggregate (Section 2) |
| **C4** | Database design & GDPR | Merise MCD/MPD, 3NF MySQL schema; GDPR analysis confirms no personal data is collected ‚Äî regulation does not apply |
| **C5** | REST API | Flask API with 8 endpoints, JWT authentication, Swagger documentation, <200 ms average response time |
| **+ML** | Machine learning (extension) | Linear Regression on 13 features; 5 models compared; 3 findings: subjectivity (R¬≤=3.6%), price anchoring, safety paradox |

---

## üë§ Author

**ZINA**  
IRONHACK ¬∑ February 2026
